<html lang="en">
    <head>
        <style>
            body {
                margin: 0;
                overflow: hidden;
                width: 100vw;
                height: 100vh;
            }
            .controls {
                position: relative;
            }
            .edit-button, .create-button, .clear-button, .add-bg-button   {
                position: absolute;
                z-index: 999999;
                top: 10px;
                left: 10px;
            }
            .create-button {
                top: 40px;
            }
            .clear-button {
                top: 70px;
            }
            .add-bg-button {
                top: 100px;
            }
        </style>
	<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/4.0.0/fabric.min.js"></script>
    </head>
    <body>
	<div class="controls">
	    <button class="add-bg-button" onclick="AddImage()">Add Background</button>
	    <button class="clear-button" onclick="ClearCanvas()">Clear</button>
	    <button class="edit-button" onclick="Edit()">Edit polygon</button>
	    <button class="create-button" id="create-polygon">Create Polygon</button>
	</div>
	<canvas id="canvas"/>
    </body>
    <script>
        let min = 99;
        let max = 999999;
        let polygonMode = true;
        let pointArray = new Array();
        let lineArray = new Array();
        let activeLine;
        let activeShape = false;

        let canvas = new fabric.Canvas('canvas', {
          width: window.innerWidth,
          height: window.innerHeight,
          backgroundColor: 'gray'
        });

	function AddImage() {
	    let ImageUrl = prompt("Add a Image URL", "https://images.developmentid.com.au/9dad5c65-da25-4266-a258-6fc402a58bdf/devsuite/Aerial.jpg")
            if (canvas) {
              fabric.Image.fromURL(ImageUrl, (oImg) => {
                  const widthRatio = canvas.width / oImg.width
                  const heightRatio = canvas.height / oImg.height
                  const maxRatio = Math.max(widthRatio, heightRatio)
                  if (heightRatio > widthRatio) {
                    oImg.scale(maxRatio)
                  } else {
                    oImg.set({
                      scaleX: widthRatio,
                      scaleY: heightRatio,
                    })
                  }
                  canvas.setBackgroundImage(oImg, canvas.renderAll.bind(canvas))
                  canvas.renderAll()
              })
            }
	}


        window.onload = function(e){ 
           prototypefabric.initCanvas();
           document.getElementById("create-polygon")
              .addEventListener("click", function() {
                 prototypefabric.polygon.drawPolygon(); 
              });
        };

	function polygonPositionHandler(dim, finalMatrix, fabricObject) {
	    let x = (fabricObject.points[this.pointIndex].x - fabricObject.pathOffset.x),
	    y = (fabricObject.points[this.pointIndex].y - fabricObject.pathOffset.y);
	    return fabric.util.transformPoint(
		{ x: x, y: y },
		fabric.util.multiplyTransformMatrices(
		    fabricObject.canvas.viewportTransform,
		    fabricObject.calcTransformMatrix()
		)
	    );
	}

	function actionHandler(eventData, transform, x, y) {
	    let polygon = transform.target,
	    currentControl = polygon.controls[polygon.__corner],
	    mouseLocalPosition = polygon.toLocalPoint(new fabric.Point(x, y), 'center', 'center'),
	    polygonBaseSize = polygon._getNonTransformedDimensions(),
	    size = polygon._getTransformedDimensions(0, 0),
	    finalPointPosition = {
		x: mouseLocalPosition.x * polygonBaseSize.x / size.x + polygon.pathOffset.x,
		y: mouseLocalPosition.y * polygonBaseSize.y / size.y + polygon.pathOffset.y
	    };
	    polygon.points[currentControl.pointIndex] = finalPointPosition;
	    return true;
	}

	function anchorWrapper(anchorIndex, fn) {
	  return function(eventData, transform, x, y) {
	    let fabricObject = transform.target,
	        absolutePoint = fabric.util.transformPoint({
	            x: (fabricObject.points[anchorIndex].x - fabricObject.pathOffset.x),
	            y: (fabricObject.points[anchorIndex].y - fabricObject.pathOffset.y),
	        }, fabricObject.calcTransformMatrix()),
	        actionPerformed = fn(eventData, transform, x, y),
	        newDim = fabricObject._setPositionDimensions({}),
	        polygonBaseSize = fabricObject._getNonTransformedDimensions(),
	        newX = (fabricObject.points[anchorIndex].x - fabricObject.pathOffset.x) / polygonBaseSize.x,
	      	    newY = (fabricObject.points[anchorIndex].y - fabricObject.pathOffset.y) / polygonBaseSize.y;
	    fabricObject.setPositionByOrigin(absolutePoint, newX + 0.5, newY + 0.5);
	    return actionPerformed;
	  }
	}

	function ClearCanvas() {
          canvas.getObjects().forEach((obj) => {
             canvas.remove(obj) 
          })
	}

	function Edit() {
	    let poly = canvas.getObjects()[0];
	    canvas.setActiveObject(poly);
	    poly.edit = !poly.edit;
	    if (poly.edit) {
		let lastControl = poly.points.length - 1;
		poly.cornerStyle = 'circle';
		poly.cornerColor = 'rgba(0,0,255,0.5)';
		poly.controls = poly.points.reduce(function(acc, point, index) {
		    acc['p' + index] = new fabric.Control({
			positionHandler: polygonPositionHandler,
			actionHandler: anchorWrapper(index > 0 ? index - 1 : lastControl, actionHandler),
			actionName: 'modifyPolygon',
			pointIndex: index
		    });
		    return acc;
		}, { });
	    } else {
		poly.cornerColor = 'blue';
		poly.cornerStyle = 'rect';
		poly.controls = fabric.Object.prototype.controls;
	    }
	    poly.hasBorders = !poly.edit;
	    canvas.requestRenderAll();
	}

        let prototypefabric = new function () {
            this.initCanvas = function () {
                canvas.on('mouse:down', function (options) {
                    if(options.target && options.target.id == pointArray[0].id){
                        prototypefabric.polygon.generatePolygon(pointArray);
                    }
                    if(polygonMode){
                        prototypefabric.polygon.addPoint(options);
                    }
                });
                canvas.on('mouse:move', function (options) {
                    if(activeLine && activeLine.class == "line"){
                        let pointer = canvas.getPointer(options.e);
                        activeLine.set({ x2: pointer.x, y2: pointer.y });

                        let points = activeShape.get("points");
                        points[pointArray.length] = {
                            x:pointer.x,
                            y:pointer.y
                        }
                        activeShape.set({
                            points: points
                        });
                        canvas.renderAll();
                    }
                    canvas.renderAll();
                });
            };
        };
        prototypefabric.polygon = {
            drawPolygon : function() {
                polygonMode = true;
                pointArray = new Array();
                lineArray = new Array();
                activeLine;
            },
            addPoint : function(options) {
                let random = Math.floor(Math.random() * (max - min + 1)) + min;
                let id = new Date().getTime() + random;
                let circle = new fabric.Circle({
                    radius: 5,
                    fill: '#ffffff',
                    stroke: '#333333',
                    strokeWidth: 0.5,
                    left: (options.e.layerX/canvas.getZoom()),
                    top: (options.e.layerY/canvas.getZoom()),
                    selectable: false,
                    hasBorders: false,
                    hasControls: false,
                    originX:'center',
                    originY:'center',
                    id:id
                });
                if(pointArray.length == 0){
                    circle.set({
                        fill:'blue'
                    })
                }
                let points = [(options.e.layerX/canvas.getZoom()),(options.e.layerY/canvas.getZoom()),(options.e.layerX/canvas.getZoom()),(options.e.layerY/canvas.getZoom())];
                line = new fabric.Line(points, {
                    strokeWidth: 2,
                    fill: '#999999',
                    stroke: '#999999',
                    class:'line',
                    originX:'center',
                    originY:'center',
                    selectable: false,
                    hasBorders: false,
                    hasControls: false,
                    evented: false
                });
                if(activeShape){
                    let pos = canvas.getPointer(options.e);
                    let points = activeShape.get("points");
                    points.push({
                        x: pos.x,
                        y: pos.y
                    });
                    let polygon = new fabric.Polygon(points,{
                        stroke:'#333333',
                        strokeWidth:1,
                        fill: '#cccccc',
                        opacity: 0.3,
                        selectable: false,
                        hasBorders: false,
                        hasControls: false,
                        evented: false
                    });
                    canvas.remove(activeShape);
                    canvas.add(polygon);
                    activeShape = polygon;
                    canvas.renderAll();
                }
                else{
                    let polyPoint = [{x:(options.e.layerX/canvas.getZoom()),y:(options.e.layerY/canvas.getZoom())}];
                    let polygon = new fabric.Polygon(polyPoint,{
                        stroke:'#333333',
                        strokeWidth:1,
                        fill: '#cccccc',
                        opacity: 0.3,
                        selectable: false,
                        hasBorders: false,
                        hasControls: false,
                        evented: false
                    });
                    activeShape = polygon;
                    canvas.add(polygon);
                }
                activeLine = line;

                pointArray.push(circle);
                lineArray.push(line);

                canvas.add(line);
                canvas.add(circle);
                canvas.selection = false;
            },
            generatePolygon : function(pointArray){
                let points = new Array();
                pointArray.forEach((point, index) => {
                    points.push({
                        x:point.left,
                        y:point.top
                    });
                    canvas.remove(point);
                })
                lineArray.forEach((line, index) => {
                    canvas.remove(line);
                })
                canvas.remove(activeShape).remove(activeLine);
                let polygon = new fabric.Polygon(points,{
                    stroke:'#333333',
                    strokeWidth: 0.5,
                    fill: 'rgba(255, 255, 255, 0.5)',
                    opacity: 1,
                    hasBorders: false,
                    objectCaching: false,
                });
                canvas.add(polygon);
                activeLine = null;
                activeShape = null;
                polygonMode = false;
                canvas.selection = true;
            }
        };
	
    </script>
</html>
